# Implementation Plan: Static Type Checking Integration

**Branch**: `005-integrate-mypy-for` | **Date**: 2025-10-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/005-integrate-mypy-for/spec.md`

## Execution Flow (/plan command scope)
```
1. Load feature spec from Input path ✓
2. Fill Technical Context ✓
3. Fill Constitution Check ✓
4. Evaluate Constitution Check → No violations
5. Execute Phase 0 → research.md ✓
6. Execute Phase 1 → contracts, data-model.md, quickstart.md ✓
7. Re-evaluate Constitution Check → PASS
8. Plan Phase 2 → Task generation approach described
9. STOP - Ready for /tasks command
```

## Summary

Integrate mypy static type checker into the Python backend (api/) to provide compile-time type validation for all Python code. This implementation adds type checking to the development workflow through strict mode configuration, pre-commit hooks, and CI/CD integration. The feature ensures type safety for FastAPI endpoints, Pydantic models, SQLAlchemy async operations, and Alembic migrations while maintaining development velocity through intelligent caching and incremental checking.

## Technical Context

**Language/Version**: Python 3.12+
**Primary Dependencies**: mypy>=1.8.0, pydantic[mypy]>=2.0.0 (plugin for Pydantic model validation)
**Storage**: Configuration in api/pyproject.toml, cache in api/.mypy_cache/
**Testing**: pytest (backend coverage validation), mypy --install-types for type stub management
**Target Platform**: Linux/macOS development environments, CI/CD pipeline
**Project Type**: Web (backend-only integration, frontend already has TypeScript strict mode)
**Performance Goals**: <5 seconds incremental check for typical single-file changes, <30 seconds full codebase check
**Constraints**: Must not block development workflow, gradual adoption support for existing code, compatible with async/await patterns
**Scale/Scope**: ~15 Python files currently, scaling to 100+ files over project lifetime

**User-provided context**: Best practices using Context7 for mypy configuration with FastAPI, SQLAlchemy, Pydantic, and async patterns.

## Constitution Check

### I. Dual-Stack Excellence
✅ **PASS** - Backend-only change, no cross-stack impact. Type checking enhances backend quality without affecting frontend.

### II. Quality-First Development
✅ **PASS** - Aligns perfectly with quality-first principle. Adds another automated quality gate (type checking) alongside existing Ruff linting.

### III. Test-Driven Implementation
✅ **PASS** - Type checking complements TDD by catching type errors before tests run. Integration with pytest ensures test code is also type-checked.

### IV. Internationalization by Design
✅ **PASS** - Not applicable to backend tooling integration.

### V. Convention Consistency
✅ **PASS** - Configuration follows project standards (pyproject.toml, English comments, conventional structure).

**Overall**: No constitutional violations. This is pure quality infrastructure enhancement.

## Project Structure

### Documentation (this feature)
```
specs/005-integrate-mypy-for/
├── plan.md              # This file
├── research.md          # Phase 0: Best practices research
├── data-model.md        # Phase 1: Configuration schema
├── quickstart.md        # Phase 1: Verification steps
├── contracts/           # Phase 1: Type checking contracts
└── tasks.md             # Phase 2: Generated by /tasks command
```

### Source Code (repository root)
```
api/
├── pyproject.toml           # Add [tool.mypy] configuration section
├── .mypy_cache/             # Auto-generated cache directory (gitignored)
├── src/
│   ├── models/              # Type-checked SQLAlchemy models
│   ├── schemas/             # Type-checked Pydantic schemas
│   ├── api/                 # Type-checked FastAPI endpoints
│   ├── core/                # Type-checked configuration and database
│   └── middleware/          # Type-checked middleware components
├── tests/                   # Type-checked test files
└── migrations/              # Excluded from strict checking (Alembic-generated)

.husky/
└── pre-commit               # Update to run mypy before commit

.github/workflows/           # CI/CD integration (if exists)
```

**Structure Decision**: Web application structure (backend-only). Mypy integration affects only the `api/` directory. Frontend already has TypeScript strict mode, so no changes needed there. Configuration is centralized in `api/pyproject.toml` following project conventions.

## Phase 0: Outline & Research

**Research completed using Context7 for mypy best practices:**

### Decision 1: Strict Mode Configuration
- **Decision**: Enable `strict = true` in pyproject.toml with selective overrides for third-party libraries
- **Rationale**: Project is early-stage with ~15 files, making it ideal for strict mode adoption. Strict mode includes all recommended checks: disallow_untyped_defs, disallow_untyped_calls, disallow_any_generics, warn_return_any, no_implicit_reexport
- **Alternatives considered**: Gradual typing (rejected - project too small to need gradual approach), Custom flag selection (rejected - strict mode is community best practice)
- **Source**: mypy official docs strict configuration guidelines

### Decision 2: Pydantic Plugin Integration
- **Decision**: Use `pydantic.mypy` plugin for enhanced Pydantic model validation
- **Rationale**: Project uses Pydantic extensively for FastAPI request/response models. Plugin provides better type inference for Pydantic's dynamic features
- **Configuration**: `plugins = ["pydantic.mypy"]` in [tool.mypy] section
- **Source**: Pydantic documentation for mypy integration

### Decision 3: Async Pattern Support
- **Decision**: No special configuration needed - mypy 1.8+ has native async/await support
- **Rationale**: Project uses asyncpg and async SQLAlchemy patterns. Modern mypy versions correctly handle AsyncIterator, Coroutine, Awaitable types
- **Validation**: Confirmed via Context7 research showing mypy's async protocol support
- **Source**: mypy async protocol documentation

### Decision 4: Migration File Handling
- **Decision**: Exclude `migrations/` directory from strict checking with `[[tool.mypy.overrides]]`
- **Rationale**: Alembic-generated migration files have specific patterns that may not align with strict type checking. Allow Alembic to manage these files without type enforcement
- **Configuration**: `module = "migrations.*"`, `ignore_errors = true`
- **Source**: Community best practices for Alembic + mypy integration

### Decision 5: Third-Party Library Stubs
- **Decision**: Use `ignore_missing_imports = true` for asyncpg and other libraries without type stubs
- **Rationale**: Some async libraries lack complete type stub coverage. Rather than blocking development, allow these imports with type inference where possible
- **Configuration**: Per-module overrides for specific libraries
- **Alternative**: Could use `--install-types` but that requires external package installation
- **Source**: mypy documentation on handling missing imports

### Decision 6: Cache Strategy
- **Decision**: Use default incremental caching with `.mypy_cache/` directory
- **Rationale**: Incremental mode provides 5-10x speedup on subsequent runs. Default cache location aligns with project conventions
- **Performance**: Expect <5s for single-file changes, <30s for full codebase
- **Source**: mypy incremental mode documentation

### Decision 7: Pre-commit Integration
- **Decision**: Add mypy check to Husky pre-commit hook alongside existing Ruff checks
- **Rationale**: Catch type errors before commit, maintaining quality-first development principle
- **Implementation**: Workspace-aware hook runs mypy only on api/ changes
- **Source**: Project's existing Husky configuration pattern

### Decision 8: CI/CD Integration
- **Decision**: Add mypy check as separate CI step after linting, before tests
- **Rationale**: Type checking is independent from linting and testing, should fail fast if types are wrong
- **Order**: lint → type-check → test → build
- **Source**: Industry best practices for CI/CD pipeline ordering

**Output**: research.md with complete best practices analysis

## Phase 1: Design & Contracts

### 1. Data Model (Configuration Schema)

**Entity**: Mypy Configuration
- **Location**: `api/pyproject.toml` under `[tool.mypy]` section
- **Fields**:
  - `python_version`: "3.12" (matches project requirement)
  - `strict`: true (enable all strict checks)
  - `plugins`: ["pydantic.mypy"] (Pydantic model support)
  - `mypy_path`: "src" (source code location)
  - `packages`: ["src"] (packages to check)
  - `exclude`: ["^migrations/", "^\\.venv/"] (excluded paths)
  - `warn_unused_configs`: true (detect unused config)
  - `show_error_codes`: true (helpful error messages)
  - `pretty`: true (better formatting)
  - `color_output`: true (terminal colors)
- **Module Overrides**:
  - `migrations.*`: ignore_errors = true
  - `asyncpg.*`: ignore_missing_imports = true (if needed)

**Entity**: Type Cache
- **Location**: `api/.mypy_cache/` (auto-generated)
- **Purpose**: Store incremental type checking state
- **Lifecycle**: Regenerated on file changes, cleaned on cache invalidation
- **Size**: ~1-5MB for current codebase, scales linearly

**Entity**: Pre-commit Hook Configuration
- **Location**: `.husky/pre-commit`
- **Workspace Detection**: Check if `api/` has changes before running mypy
- **Command**: `cd api && uv run mypy .`
- **Failure Behavior**: Block commit if type errors found

### 2. API Contracts

**Contract 1: Type Checking Service**
```yaml
Input:
  - Python source files in api/src/
  - Configuration from api/pyproject.toml
  - Cache from api/.mypy_cache/ (if exists)

Output:
  - Exit code: 0 (success) or 1 (type errors found)
  - Error report: List of type mismatches with file:line:column
  - Summary: Count of errors, files checked, time elapsed

Guarantees:
  - All type annotations validated against usage
  - Async patterns correctly type-checked
  - Pydantic models properly validated
  - Incremental checking when cache available
```

**Contract 2: Pre-commit Type Check**
```yaml
Trigger: Git commit with changes in api/

Process:
  1. Detect api/ file changes
  2. Run mypy on entire api/ codebase (not just changed files)
  3. Report errors to console
  4. Allow/block commit based on result

Success: Exit code 0, commit proceeds
Failure: Exit code 1, commit blocked, errors displayed
```

**Contract 3: CI/CD Type Check**
```yaml
Stage: After linting, before testing

Steps:
  1. Install mypy and dependencies (uv sync --dev)
  2. Run mypy with same config as local
  3. Fail pipeline if type errors found

Output:
  - GitHub Actions annotation for each error
  - Summary comment on PR (if applicable)
  - Pipeline status: pass/fail
```

### 3. Contract Tests

**Test File**: `tests/test_type_checking.py`
```python
"""Contract tests for mypy type checking integration."""

def test_mypy_installed():
    """Verify mypy is available in dev dependencies."""
    # Assert: mypy command exists and returns version

def test_mypy_config_exists():
    """Verify mypy configuration is present."""
    # Assert: [tool.mypy] section exists in pyproject.toml

def test_mypy_runs_successfully():
    """Verify mypy can execute on codebase."""
    # Assert: mypy command exits with code 0 or 1 (not crash)

def test_mypy_cache_created():
    """Verify mypy creates cache directory."""
    # Assert: .mypy_cache/ exists after mypy run

def test_strict_mode_enabled():
    """Verify strict mode is configured."""
    # Assert: strict = true in configuration

def test_pydantic_plugin_configured():
    """Verify Pydantic plugin is enabled."""
    # Assert: pydantic.mypy in plugins list

def test_migrations_excluded():
    """Verify migration files are excluded."""
    # Assert: migrations pattern in exclude or overrides

def test_type_error_detection():
    """Verify mypy detects intentional type errors."""
    # Create temp file with type error
    # Assert: mypy reports error for that file
```

**Expected State**: All tests fail initially (no mypy installed, no configuration)

### 4. Integration Test Scenarios

**Scenario 1: Valid Type Annotations**
```python
# Given: FastAPI endpoint with proper type hints
from fastapi import APIRouter
from schemas.health import HealthResponse

router = APIRouter()

@router.get("/health", response_model=HealthResponse)
async def health_check() -> HealthResponse:
    return HealthResponse(status="healthy")

# When: mypy checks this file
# Then: No type errors reported
```

**Scenario 2: Type Mismatch Detection**
```python
# Given: Function with incorrect return type
async def get_user_age(user_id: int) -> int:
    return "not a number"  # Type error

# When: mypy checks this file
# Then: Error reported: Incompatible return value type (got "str", expected "int")
```

**Scenario 3: Async Pattern Validation**
```python
# Given: Async function with coroutine handling
from sqlalchemy.ext.asyncio import AsyncSession

async def get_session() -> AsyncSession:
    # Correct async pattern
    async with engine.begin() as conn:
        yield conn

# When: mypy checks this file
# Then: Correctly validates AsyncIterator vs Coroutine types
```

### 5. Quickstart Test Scenarios

See `quickstart.md` for detailed verification steps.

### 6. Agent Context Update

Update performed via: `.specify/scripts/bash/update-agent-context.sh claude`

**Output**: `data-model.md`, `contracts/type-checking-contract.yaml`, `tests/test_type_checking.py` (failing), `quickstart.md`, `CLAUDE.md` (updated)

## Phase 2: Task Planning Approach

**Task Generation Strategy**:
1. Load contracts from Phase 1
2. Create dependency-ordered task list following TDD principles
3. Each contract generates:
   - Configuration task
   - Contract test task [P]
   - Implementation task to make test pass
   - Integration validation task

**Ordering Strategy**:
- **Tests First**: Contract tests before implementation (TDD)
- **Dependencies**: Configuration → Tests → Implementation → Integration
- **Parallelizable**: Tests can be written in parallel [P]
- **Sequential**: Configuration must complete before testing

**Estimated Task Breakdown**:
1. Add mypy to dev dependencies (pyproject.toml)
2. Create mypy configuration section [P]
3. Write contract test for mypy installation [P]
4. Write contract test for configuration validation [P]
5. Write contract test for strict mode [P]
6. Write contract test for cache creation [P]
7. Write contract test for Pydantic plugin [P]
8. Write contract test for exclusions [P]
9. Write contract test for error detection [P]
10. Run mypy on codebase, document initial errors
11. Fix type errors in src/models/ [P per file]
12. Fix type errors in src/schemas/ [P per file]
13. Fix type errors in src/api/ [P per file]
14. Fix type errors in src/core/ [P per file]
15. Fix type errors in src/middleware/ [P per file]
16. Fix type errors in tests/ [P per file]
17. Verify all contract tests pass
18. Update pre-commit hook configuration
19. Test pre-commit hook with intentional type error
20. Add .mypy_cache to .gitignore
21. Create quickstart.md validation guide
22. Run full quickstart validation
23. Update CLAUDE.md with mypy context
24. Document mypy integration in project README (if needed)

**Estimated Output**: 24-30 numbered, ordered tasks in tasks.md

**IMPORTANT**: This phase is executed by the /tasks command, NOT by /plan

## Phase 3+: Future Implementation

**Phase 3**: Task execution (/tasks command creates tasks.md)
**Phase 4**: Implementation (execute tasks.md following constitutional principles)
**Phase 5**: Validation (run tests, execute quickstart.md, verify type checking works)

## Complexity Tracking

*No constitutional violations - no complexity justification needed.*

## Progress Tracking

**Phase Status**:
- [x] Phase 0: Research complete
- [x] Phase 1: Design complete
- [x] Phase 2: Task planning approach described
- [ ] Phase 3: Tasks generated (/tasks command)
- [ ] Phase 4: Implementation complete
- [ ] Phase 5: Validation passed

**Gate Status**:
- [x] Initial Constitution Check: PASS
- [x] Post-Design Constitution Check: PASS
- [x] All technical unknowns resolved
- [x] No complexity deviations

---
*Based on Constitution v1.1.0 - See `.specify/memory/constitution.md`*
